<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta charset="UTF-8">
  <title>rspeare.github.io</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/cayman.css">
  
</head>


  <body>
    <section class="page-header">
  <h1 <a href="/" class="project-name">rspeare.github.io </a> </h1> 
  <h2 class="project-tagline"></h2>
  <a href="/" class="btn">Blog</a>  

  <a class="btn" <a href="https://github.com/rspeare"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">rspeare</span></a>
 </a>


  <a class="btn" <a href="https://twitter.com/waiting4spark"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">waiting4spark</span></a>
 </a>

<a href="/about/" class="btn">About</a>  
</section>


    <section class="main-content">
      
      <style TYPE="text/css">
code.has-jax {font: inherit; font-size: 100%; background: inherit; border: inherit;}
</style>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] // removed 'code' entry
    }
});
MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

<h2>Facility Location as Adaptive K-means</h2>
<p class="meta">03 Jan 2016</p>

<div dir="ltr" style="text-align: left;" trbidi="on">In linear programming, a 
typical problem is the following: we have $N$ facilities, which we can choose 
to open or not open, in order to serve $M$ customers, who are strewn 
throughout the world. We would like to minimize the operational cost of 
serving our customers from these facilities, which can be summarized as: 

\begin{eqnarray} 
\mathrm{startup} \ \mathrm{costs} &amp;=&amp; \sum_f s_f y_f\\ 
y_f &amp;=&amp; 0,1 
\end{eqnarray} 

Where $y_f$ is a binary variable -- zero or one -- based on whether we choose 
to open facility $f$. $s_f$ is obviously the associated cost for opening that 
specific facility. We also have transit costs from serving our customers, 
which might be of the very simple form: 

\begin{eqnarray} 
\mathrm{transit} \ \mathrm{costs} &amp;=&amp; \sum_c \sum_f X_{cf} 
D(\mathbf{x}_c, \mathbf{x}_f)\\ 
X_{cf} &amp;=&amp; 0,1 
\end{eqnarray} 

Where $X_{cf}$ is a binary matrix that denotes whether customer $c$ was 
assigned to facility $f$. $D(x_1,x_2)$, is our distance metric, which could be 
Euclidean or "Manhattan" -- where we only take steps to the left or right, up 
or down, no diagonal lines between destinations -- or maybe just a query in 
google maps. 

Adding these to costs together we get a loss function of sorts: 

\begin{eqnarray} 
J &amp;=&amp;  \sum_c \sum_f X_{cf} D(\mathbf{x}_c, \mathbf{x}_f)+ \sum_f s_f 
y_f 
\end{eqnarray} 

which we would like to minimize. There are some simple constraints on our 
binary variables that we can articulate mathematically. Say each facility has 
an associated production capacity $c_f$ and each customer has an associated 
demand $d_c$. Then we have to make sure that the assignments are not 
overworking our facilities: 

\begin{eqnarray} 
\sum_c d_c X_{cf} &amp; \le &amp; c_f y_f \ \forall \ f 
\end{eqnarray} 

Notice I've multiplied by $y_f$ on the RHS. Another constraint we need to have 
is that every customer is served by exactly one facility -- no redundancy: 

\begin{eqnarray} 
\sum_f X_{cf} &amp;=&amp; 1\ \forall \ c 
\end{eqnarray} 

We can also require more explicitly that facilities who are turned off do not 
get any assignments: 

\begin{eqnarray} 
X_{cf} &amp; \le &amp; y_f \ \ \ \forall \ c,f 
\end{eqnarray} 

That's a ton of constraints, but each of them are linear and so we have well 
defined linear program. Given $N$ facility locations and $M$ customer 
locations, with the associated capacities, demands, and start up costs, we can 
find the global optimum of this thing with $N(M+1)$ decision variables, $X$ 
and $y$. 

Turns out this problem is very similar to K means. Because what we are 
essentially doing is breaking down our customers into "facility clusters". 
What if we promoted all customers to facilities themselves? (Or at least gave 
them the option). Then the distance function $D(\mathbf{x}_1,\mathbf{x}_2)$ is 
simply the square root of the $L_2$ norm associated with a mixture of 
Gaussians with a diagonal covariance matrix. Let $\mathbf{x}_2$ be the 
facility, or centroid of the $k^\mathrm{th}$ cluster, then we have: 

\begin{eqnarray} 
\mathrm{Let} \ \ \mathbf{x}_2 &amp;=&amp; \mu_k \\ 
\mathbf{\Sigma} &amp;=&amp; \mathbf{1} \\ 
\mathrm{Then} \ \ D(\mathbf{x}_1,\mathbf{x}_1) &amp;=&amp; 
\sqrt{\left(\mathbf{x}_1-\mathbf{\vec{\mu}}_k\right) 
\mathbf{\Sigma}^{-1}\left(\mathbf{x}_1-\mathbf{\vec{\mu}}_k\right)} 
\end{eqnarray} 

For a mixture of Gaussians density Estimation, our PDF is: 

\begin{eqnarray} 
P(\mathbf{x}) &amp;=&amp; \sum_{k=1}^K \mathcal{N}\left(\mu_k,\mathbf{\Sigma} 
\right) 
\end{eqnarray} 

and the log likelihood for our sequence of customers/facilities is: 

\begin{eqnarray} 
-\log \mathcal{L}(X \vert \lbrace \mu \rbrace_{k=1}^K )&amp;=&amp; \sum_k 
\sum_{ n \in c_k} \frac{\left(\mathbf{x}_n-\mathbf{\mu}_k 
\right)^2}{2\sigma^2}+K\sqrt{2\pi \sigma^2} 
\end{eqnarray} 

I've kept the $\sigma^2$ terms for clarity. Notice that the second term in 
this negative log likelihood, or loss function is the normalization factor: it 
penalizes a high level of total clusters $K$, preventing overfitting. This 
loss function -- apart from the quadratic nature of the summand -- is exactly 
like the objective in our facility location problem. The startup cost for 
every "facility" in this example would be 

\begin{eqnarray} 
s_f &amp;=&amp; \sqrt{2\pi \sigma^2} \ \ \forall f 
\end{eqnarray} 

And the variance of our gaussians we would set to unity: $\sigma \to 1$. Let's 
rewrite the negative log likelihood, but in decision variable language: 

\begin{eqnarray} 
J^\prime &amp;=&amp;  \frac{1}{2}\sum_i \sum_j X_{ij} D(\mathbf{x}_i, 
\mathbf{x}_j)^2+ \sum_j s_j y_j \\ 
s_i &amp;=&amp; \sqrt{2\pi}\\ 
\end{eqnarray} 

We have not yet specified the capacity of our clusters or the "demand" of each 
data point. A simple choice would be to set some upper limit on the size of 
each cluster, and give every data point the same weight or demand: 

\begin{eqnarray} 
d_i &amp;=&amp; 1 \ \ \forall \ i \\ 
c_j &amp;=&amp; c_\mathrm{max} \ \ \forall \ j 
\end{eqnarray} 

This is still a linear program, just with a slightly different list of 
coefficients on the first term! To solve such a system we would need $N(N+1)$ 
decision variables, which could be prohibitive with large systems, but thanks 
to interior point solvers and very clever routines for integer programming we 
can actually run this "adaptive" K-means algorithm in polynomial time! 
</div>




      <footer class="site-footer">
  <span class="site-footer-owner"><a href="http://localhost:4000">rspeare.github.io</a> is maintained by <a href="">rspeare</a>.</span>
  <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>

  <a href="https://www.linkedin.com/in/rob-speare-aaa6834a">
    <span class="icon  icon--linkedin">
      <svg viewBox="0 0 10000 10000" >
        <path fill="#828282" d="M150.65,100.682c0,27.992-22.508,50.683-50.273,50.683c-27.765,0-50.273-22.691-50.273-50.683
        C50.104,72.691,72.612,50,100.377,50C128.143,50,150.65,72.691,150.65,100.682z M143.294,187.333H58.277V462h85.017V187.333z
        M279.195,187.333h-81.541V462h81.541c0,0,0-101.877,0-144.181c0-38.624,17.779-61.615,51.807-61.615
        c31.268,0,46.289,22.071,46.289,61.615c0,39.545,0,144.181,0,144.181h84.605c0,0,0-100.344,0-173.915
        s-41.689-109.131-99.934-109.131s-82.768,45.369-82.768,45.369V187.333z"/>
      </svg>
    </span>

    <span class="username"></span>
  </a>

</footer>
 

    </section>

  </body>
</html>
